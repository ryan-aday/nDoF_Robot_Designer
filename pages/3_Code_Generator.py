import json
from typing import List

import streamlit as st


def _float_list(values, fallback, length):
    if values is None:
        return [fallback] * length
    padded = list(values) + [fallback] * max(0, length - len(values))
    return padded[:length]


def _extract_lengths(joints: List[dict], key: str, fallback: float) -> List[float]:
    lengths = []
    for entry in joints:
        length = entry.get(key)
        if length is None:
            try:
                length = float(entry.get(key.lower().replace(" ", "_"), fallback))
            except Exception:
                length = fallback
        lengths.append(length)
    return lengths


def _sanitize_scalar_list(values, fallback: float, length: int) -> List[float]:
    cleaned = []
    for i in range(length):
        try:
            cleaned.append(float(values[i]))
        except Exception:
            cleaned.append(fallback)
    return cleaned


def generate_c_template(
    dof,
    joint_types,
    link_lengths,
    joint_body_lengths,
    joint_body_masses,
    joint_body_inertia,
    start_state,
    target_state,
    steps,
    frame_ms,
):
    jt_map = [0 if jt == "revolute" else 1 for jt in joint_types]
    fmt_list = lambda arr: ", ".join(f"{float(v):.6f}" for v in arr)
    template = """// Autogenerated minimal controller for a {dof}-DoF serial robot
// Joint types: 0 = revolute, 1 = prismatic
// Based on numerical targets from the n-DoF Robot Designer app.
#include <math.h>
#include <stdio.h>

#define DOF {dof}

static const double link_lengths[DOF] = {{ {link_lengths} }};
static const double joint_body_lengths[DOF] = {{ {joint_body_lengths} }};
static const double joint_body_masses[DOF] = {{ {joint_body_masses} }};
static const double joint_body_inertia[DOF] = {{ {joint_body_inertia} }};
static const int joint_types[DOF] = {{ {jt_map} }};
static double start_state[DOF] = {{ {start_state} }};
static double target_state[DOF] = {{ {target_state} }};

// TODO: Implement hardware-specific I/O.
void hw_init(void) {{ /* setup CAN/ethernet/uart, encoders, safety interlocks */ }}
void send_joint_command(int joint_idx, double value) {{ /* command actuators */ }}
void delay_ms(int ms) {{ /* platform-specific sleep */ }}

void move_to_state(const double* state) {{
    for (int i = 0; i < DOF; ++i) {{
        send_joint_command(i, state[i]);
    }}
}}

void interpolate_and_move(const double* a, const double* b, int steps) {{
    double interp[DOF];
    for (int s = 0; s <= steps; ++s) {{
        double alpha = (double)s / (double)steps;
        for (int j = 0; j < DOF; ++j) {{
            interp[j] = a[j] + alpha * (b[j] - a[j]);
        }}
        move_to_state(interp);
        delay_ms({frame_ms});
    }}
}}

int main(void) {{
    hw_init();
    interpolate_and_move(start_state, target_state, {steps});
    interpolate_and_move(target_state, start_state, {steps});
    return 0;
}}
""".format(
        dof=dof,
        link_lengths=fmt_list(link_lengths),
        joint_body_lengths=fmt_list(joint_body_lengths),
        joint_body_masses=fmt_list(joint_body_masses),
        joint_body_inertia=fmt_list(joint_body_inertia),
        jt_map=", ".join(map(str, jt_map)),
        start_state=fmt_list(start_state),
        target_state=fmt_list(target_state),
        frame_ms=frame_ms,
        steps=steps,
    )
    return template


def generate_cpp_template(
    dof,
    joint_types,
    link_lengths,
    joint_body_lengths,
    joint_body_masses,
    joint_body_inertia,
    start_state,
    target_state,
    steps,
    frame_ms,
):
    jt_map = ["JointType::Revolute" if jt == "revolute" else "JointType::Prismatic" for jt in joint_types]
    fmt_list = lambda arr: ", ".join(f"{float(v):.6f}" for v in arr)
    template = """// Autogenerated minimal C++ controller for a {dof}-DoF serial robot
// Joint types: enum class JointType {{ Revolute, Prismatic }}
// Based on numerical targets from the n-DoF Robot Designer app.
#include <array>
#include <chrono>
#include <cmath>
#include <thread>

enum class JointType {{ Revolute, Prismatic }};
constexpr int DOF = {dof};

using Vector = std::array<double, DOF>;
static const Vector kLinkLengths = {{ {link_lengths} }};
static const Vector kJointBodyLengths = {{ {joint_body_lengths} }};
static const Vector kJointBodyMasses = {{ {joint_body_masses} }};
static const Vector kJointBodyInertia = {{ {joint_body_inertia} }};
static const std::array<JointType, DOF> kJointTypes = {{ {jt_map} }};
static Vector start_state = {{ {start_state} }};
static Vector target_state = {{ {target_state} }};

void HwInit() {{ /* setup CAN/ethernet/uart, encoders, safety interlocks */ }}
void SendJointCommand(int joint_idx, double value) {{ /* command actuators */ }}

void MoveToState(const Vector& state) {{
  for (int i = 0; i < DOF; ++i) {{
    SendJointCommand(i, state[i]);
  }}
}}

void InterpolateAndMove(const Vector& a, const Vector& b, int steps) {{
  Vector interp{{}};
  for (int s = 0; s <= steps; ++s) {{
    double alpha = static_cast<double>(s) / static_cast<double>(steps);
    for (int j = 0; j < DOF; ++j) {{
      interp[j] = a[j] + alpha * (b[j] - a[j]);
    }}
    MoveToState(interp);
    std::this_thread::sleep_for(std::chrono::milliseconds({frame_ms}));
  }}
}}

int main() {{
  HwInit();
  InterpolateAndMove(start_state, target_state, {steps});
  InterpolateAndMove(target_state, start_state, {steps});
  return 0;
}}
""".format(
        dof=dof,
        link_lengths=fmt_list(link_lengths),
        joint_body_lengths=fmt_list(joint_body_lengths),
        joint_body_masses=fmt_list(joint_body_masses),
        joint_body_inertia=fmt_list(joint_body_inertia),
        jt_map=", ".join(jt_map),
        start_state=fmt_list(start_state),
        target_state=fmt_list(target_state),
        frame_ms=frame_ms,
        steps=steps,
    )
    return template


def generate_fanuc_template(dof, joint_types, start_state, target_state, steps):
    fmt_list = lambda arr: ", ".join(f"{float(v):.4f}" for v in arr)
    template = """-- Minimal FANUC-style TP pseudo-code for a {dof}-axis robot
-- Populate joint targets from the JSON report and insert controller-specific
-- speed/accel/safety details before deployment.
-- Joint types: {', '.join(joint_types)}

PROGRAM START_TO_TARGET
  ! Move to start
  J P[1] {start_state}
  ! Interpolate to target over {steps} steps
  FOR S = 0 TO {steps}
    R[1] = S / {steps}.0
    ; Linear interpolation per joint
    -- Replace R[2]..R[n] with controller registers as needed
  ENDFOR
  J P[2] {target_state}
END

PROGRAM TARGET_TO_START
  J P[2] {target_state}
  FOR S = 0 TO {steps}
    R[1] = S / {steps}.0
  ENDFOR
  J P[1] {start_state}
END
""".format(
        dof=dof,
        joint_types=", ".join(joint_types),
        start_state=fmt_list(start_state),
        target_state=fmt_list(target_state),
        steps=steps,
    )
    return template


def generate_kuka_template(dof, joint_types, start_state, target_state, steps):
    fmt_list = lambda arr: ", ".join(f"{float(v):.4f}" for v in arr)
    template = """; Minimal KUKA KRL pseudo-code for a {dof}-axis robot
; Joint types: {joint_types}
DEF START_TO_TARGET( )
  ; Move to start
  PTP {{AXIS: {start_state}}}
  ; Interpolate to target over {steps} steps
  FOR S = 0 TO {steps}
    DECL REAL ALPHA
    ALPHA = S / {steps}.0
    ; Compute intermediate joints (fill in controller-specific logic)
  ENDFOR
  PTP {{AXIS: {target_state}}}
END

DEF TARGET_TO_START( )
  PTP {{AXIS: {target_state}}}
  FOR S = 0 TO {steps}
    DECL REAL ALPHA
    ALPHA = S / {steps}.0
  ENDFOR
  PTP {{AXIS: {start_state}}}
END
""".format(
        dof=dof,
        joint_types=", ".join(joint_types),
        start_state=fmt_list(start_state),
        target_state=fmt_list(target_state),
        steps=steps,
    )
    return template


def main():
    st.title("Code Generator for Physical Robots")
    st.markdown(
        """
        Use a JSON report from the Robot Designer page (or enter values manually) to produce
        scaffolded C, C++, or vendor-style (FANUC/KUKA) motion code that drives the robot from
        its start state to a target pose and back again. The generated snippets interpolate
        joint commands at 60 FPS by default and carry joint body metadata for downstream safety
        checks.

        References: [Screw theory](https://en.wikipedia.org/wiki/Screw_theory) |
        [Robot Kinematics and Dynamics](https://u0011821.pages.gitlab.kuleuven.be/robotics/2009-HermanBruyninckx-robot-kinematics-and-dynamics.pdf) |
        [Numerical IK (Modern Robotics)](https://modernrobotics.northwestern.edu/nu-gm-book-resource/6-2-numerical-inverse-kinematics-part-1-of-2/) |
        [Gradient descent in robotics](https://www.meegle.com/en_us/topics/gradient-descent/gradient-descent-in-robotics) |
        [Screw-theory improvements](https://journals.sagepub.com/doi/10.5772/60834) |
        [Trajectory smoothing](https://www.witpress.com/Secure/elibrary/papers/HPSM25/HPSM25011FU1.pdf) |
        [Manipulator optimization](https://www.sciencedirect.com/science/article/abs/pii/S0094114X05001424) |
        [Forward kinematics via DH](https://automaticaddison.com/homogeneous-transformation-matrices-using-denavit-hartenberg/).
        """
    )

    st.sidebar.header("Source data")
    uploaded = st.sidebar.file_uploader("Upload JSON report", type="json")
    default_report = {
        "desired_dof": 3,
        "joints": [
            {"Joint": 1, "Type": "revolute", "Length (m)": 0.25},
            {"Joint": 2, "Type": "revolute", "Length (m)": 0.25},
            {"Joint": 3, "Type": "revolute", "Length (m)": 0.25},
        ],
        "joint_body_lengths": [0.05, 0.05, 0.05],
        "joint_body_masses": [0.5, 0.5, 0.5],
        "joint_body_inertias": [[0.01, 0.0, 0.0], [0.01, 0.0, 0.0], [0.01, 0.0, 0.0]],
        "home_state": [0.0, 0.0, 0.0],
        "ik_solution": [0.35, -0.2, 0.12],
        "target": [0.55, 0.1, 0.05],
        "solver": "Forward finite (default)",
        "gravity": 9.81,
    }

    report = default_report
    if uploaded:
        try:
            report = json.load(uploaded)
        except Exception as exc:  # pragma: no cover - user input guard
            st.error(f"Failed to read JSON: {exc}")
            return

    joints_data = report.get("joints", default_report["joints"])
    dof = len(joints_data)
    st.write(f"Loaded DoF: {dof}")
    st.write(f"Gravity used in report: {report.get('gravity', 9.81)} m/sÂ²")

    st.subheader("Joint table (editable)")
    edited_joints = st.data_editor(
        joints_data,
        column_config={
            "Type": st.column_config.SelectboxColumn("Type", options=["revolute", "prismatic"]),
            "Length (m)": st.column_config.NumberColumn("Length (m)", min_value=0.01, step=0.01),
        },
        num_rows="dynamic",
        use_container_width=True,
        key="codegen_joints",
    )

    joint_types = [row.get("Type", "revolute") for row in edited_joints]
    link_lengths = _extract_lengths(edited_joints, "Length (m)", 0.5)

    st.subheader("Joint body properties (offsets)")
    joint_body_table = [
        {
            "Joint": i + 1,
            "Body length (m)": report.get("joint_body_lengths", default_report["joint_body_lengths"])[i]
            if i < len(report.get("joint_body_lengths", []))
            else 0.05,
            "Body mass (kg)": report.get("joint_body_masses", default_report["joint_body_masses"])[i]
            if i < len(report.get("joint_body_masses", []))
            else 0.5,
            "Body inertia (kg*m^2)": report.get("joint_body_inertias", default_report["joint_body_inertias"])[i][0]
            if i < len(report.get("joint_body_inertias", []))
            else 0.01,
        }
        for i in range(len(edited_joints))
    ]
    edited_bodies = st.data_editor(
        joint_body_table,
        column_config={
            "Body length (m)": st.column_config.NumberColumn("Body length (m)", min_value=0.0, step=0.01),
            "Body mass (kg)": st.column_config.NumberColumn("Body mass (kg)", min_value=0.0, step=0.01),
            "Body inertia (kg*m^2)": st.column_config.NumberColumn("Body inertia (kg*m^2)", min_value=0.0, step=0.001),
        },
        num_rows="fixed",
        use_container_width=True,
        key="codegen_joint_bodies",
    )

    joint_body_lengths = _sanitize_scalar_list([row.get("Body length (m)", 0.05) for row in edited_bodies], 0.05, len(edited_bodies))
    joint_body_masses = _sanitize_scalar_list([row.get("Body mass (kg)", 0.5) for row in edited_bodies], 0.5, len(edited_bodies))
    joint_body_inertia = _sanitize_scalar_list([row.get("Body inertia (kg*m^2)", 0.01) for row in edited_bodies], 0.01, len(edited_bodies))

    st.subheader("Motion states (start and target)")
    col_start, col_target = st.columns(2)
    with col_start:
        start_state = _float_list(report.get("home_state"), 0.0, len(edited_joints))
        start_state = st.data_editor(
            {f"J{i+1}": start_state[i] for i in range(len(edited_joints))},
            use_container_width=True,
            num_rows="fixed",
            key="start_state_editor",
        )
        start_state = [start_state[f"J{i+1}"] for i in range(len(edited_joints))]
    with col_target:
        target_state = _float_list(report.get("ik_solution"), 0.0, len(edited_joints))
        target_state = st.data_editor(
            {f"J{i+1}": target_state[i] for i in range(len(edited_joints))},
            use_container_width=True,
            num_rows="fixed",
            key="target_state_editor",
        )
        target_state = [target_state[f"J{i+1}"] for i in range(len(edited_joints))]

    st.subheader("Code generation parameters")
    steps = st.slider("Interpolation steps per leg", 60, 2400, 960, step=60)
    frame_ms = st.number_input("Frame delay (ms)", 5, 40, 16, 1)
    language = st.selectbox("Target language", ["C", "C++", "FANUC TP (pseudo)", "KUKA KRL (pseudo)"])

    if language == "C++":
        code_output = generate_cpp_template(
            dof=len(edited_joints),
            joint_types=joint_types,
            link_lengths=link_lengths,
            joint_body_lengths=joint_body_lengths,
            joint_body_masses=joint_body_masses,
            joint_body_inertia=joint_body_inertia,
            start_state=start_state,
            target_state=target_state,
            steps=steps,
            frame_ms=frame_ms,
        )
        language_key = "cpp"
        code_lang = "cpp"
    elif language == "FANUC TP (pseudo)":
        code_output = generate_fanuc_template(
            dof=len(edited_joints),
            joint_types=joint_types,
            start_state=start_state,
            target_state=target_state,
            steps=steps,
        )
        language_key = "fanuc_tp"
        code_lang = "text"
    elif language == "KUKA KRL (pseudo)":
        code_output = generate_kuka_template(
            dof=len(edited_joints),
            joint_types=joint_types,
            start_state=start_state,
            target_state=target_state,
            steps=steps,
        )
        language_key = "kuka_krl"
        code_lang = "text"
    else:
        code_output = generate_c_template(
            dof=len(edited_joints),
            joint_types=joint_types,
            link_lengths=link_lengths,
            joint_body_lengths=joint_body_lengths,
            joint_body_masses=joint_body_masses,
            joint_body_inertia=joint_body_inertia,
            start_state=start_state,
            target_state=target_state,
            steps=steps,
            frame_ms=frame_ms,
        )
        language_key = "c"
        code_lang = "c"

    st.subheader("Generated code")
    st.code(code_output, language=code_lang)

    augmented_report = report.copy()
    augmented_report.update(
        {
            "joints": edited_joints,
            "joint_body_lengths": joint_body_lengths,
            "joint_body_masses": joint_body_masses,
            "joint_body_inertias": [[val, 0.0, 0.0] for val in joint_body_inertia],
            "home_state": start_state,
            "ik_solution": target_state,
            "gravity": report.get("gravity", 9.81),
            "codegen": {"steps": steps, "frame_ms": frame_ms, "language": language},
            language_key: code_output,
        }
    )

    st.download_button(
        "Download updated JSON (with code)",
        data=json.dumps(augmented_report, indent=2),
        file_name="robot_codegen.json",
        use_container_width=True,
    )


if __name__ == "__main__":
    main()
