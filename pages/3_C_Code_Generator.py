import json
from typing import List

import streamlit as st


def _float_list(values, fallback, length):
    if values is None:
        return [fallback] * length
    padded = list(values) + [fallback] * max(0, length - len(values))
    return padded[:length]


def _extract_lengths(joints: List[dict]) -> List[float]:
    lengths = []
    for entry in joints:
        length = entry.get("Length (m)")
        if length is None:
            try:
                length = float(entry.get("length", 0.1))
            except Exception:
                length = 0.1
        lengths.append(length)
    return lengths


def generate_c_template(dof, joint_types, link_lengths, start_state, target_state, steps, frame_ms):
    jt_map = [0 if jt == "revolute" else 1 for jt in joint_types]
    fmt_list = lambda arr: ", ".join(f"{v:.6f}" for v in arr)
    template = f"""// Autogenerated minimal controller for a {dof}-DoF serial robot
// Joint types: 0 = revolute, 1 = prismatic
// Based on numerical IK targets from the n-DoF Robot Designer app.
#include <math.h>
#include <stdio.h>

#define DOF {dof}

static const double link_lengths[DOF] = {{{fmt_list(link_lengths)}}};
static const int joint_types[DOF] = {{{', '.join(map(str, jt_map))}}};
static double start_state[DOF] = {{{fmt_list(start_state)}}};
static double target_state[DOF] = {{{fmt_list(target_state)}}};

// TODO: Implement hardware-specific I/O.
void hw_init(void) {{ /* setup CAN/ethernet/uart, encoders, safety interlocks */ }}
void send_joint_command(int joint_idx, double value) {{ /* command actuators */ }}
void delay_ms(int ms) {{ /* platform-specific sleep */ }}

void move_to_state(const double* state) {{
    for (int i = 0; i < DOF; ++i) {{
        send_joint_command(i, state[i]);
    }}
}}

void interpolate_and_move(const double* a, const double* b, int steps) {{
    double interp[DOF];
    for (int s = 0; s <= steps; ++s) {{
        double alpha = (double)s / (double)steps;
        for (int j = 0; j < DOF; ++j) {{
            interp[j] = a[j] + alpha * (b[j] - a[j]);
        }}
        move_to_state(interp);
        delay_ms({frame_ms});
    }}
}}

int main(void) {{
    hw_init();
    interpolate_and_move(start_state, target_state, {steps});
    interpolate_and_move(target_state, start_state, {steps});
    return 0;
}}
"""
    return template


def main():
    st.title("C Code Generator for Physical Robots")
    st.markdown(
        """
        Use a JSON report from the Robot Designer page (or enter values manually) to produce
        functional C scaffolding that drives the robot from its start state to a target pose
        and back again. The generated code interpolates joint commands at 60 FPS by default.

        References: [Screw theory](https://en.wikipedia.org/wiki/Screw_theory) |
        [Robot Kinematics and Dynamics](https://u0011821.pages.gitlab.kuleuven.be/robotics/2009-HermanBruyninckx-robot-kinematics-and-dynamics.pdf) |
        [Numerical IK (Modern Robotics)](https://modernrobotics.northwestern.edu/nu-gm-book-resource/6-2-numerical-inverse-kinematics-part-1-of-2/) |
        [Gradient descent in robotics](https://www.meegle.com/en_us/topics/gradient-descent/gradient-descent-in-robotics) |
        [Screw-theory improvements](https://journals.sagepub.com/doi/10.5772/60834) |
        [Trajectory smoothing](https://www.witpress.com/Secure/elibrary/papers/HPSM25/HPSM25011FU1.pdf) |
        [Manipulator optimization](https://www.sciencedirect.com/science/article/abs/pii/S0094114X05001424) |
        [Forward kinematics via DH](https://automaticaddison.com/homogeneous-transformation-matrices-using-denavit-hartenberg/).
        """
    )

    st.sidebar.header("Source data")
    uploaded = st.sidebar.file_uploader("Upload JSON report", type="json")
    default_report = {
        "desired_dof": 3,
        "joints": [
            {"Joint": 1, "Type": "revolute", "Length (m)": 0.25},
            {"Joint": 2, "Type": "revolute", "Length (m)": 0.20},
            {"Joint": 3, "Type": "revolute", "Length (m)": 0.15},
        ],
        "home_state": [0.0, 0.0, 0.0],
        "ik_solution": [0.35, -0.2, 0.12],
        "target": [0.55, 0.1, 0.05],
        "solver": "Damped least squares",
        "gravity": 9.81,
    }

    report = default_report
    if uploaded:
        try:
            report = json.load(uploaded)
        except Exception as exc:  # pragma: no cover - user input guard
            st.error(f"Failed to read JSON: {exc}")
            return

    joints_data = report.get("joints", default_report["joints"])
    dof = len(joints_data)
    st.write(f"Loaded DoF: {dof}")
    st.write(f"Gravity used in report: {report.get('gravity', 9.81)} m/sÂ²")

    st.subheader("Joint table (editable)")
    edited_joints = st.data_editor(
        joints_data,
        column_config={
            "Type": st.column_config.SelectboxColumn("Type", options=["revolute", "prismatic"]),
            "Length (m)": st.column_config.NumberColumn("Length (m)", min_value=0.01, step=0.01),
        },
        num_rows="dynamic",
        use_container_width=True,
        key="c_codegen_joints",
    )

    joint_types = [row.get("Type", "revolute") for row in edited_joints]
    link_lengths = _extract_lengths(edited_joints)

    st.subheader("Motion states (start and target)")
    col_start, col_target = st.columns(2)
    with col_start:
        start_state = _float_list(report.get("home_state"), 0.0, len(edited_joints))
        start_state = st.data_editor(
            {f"J{i+1}": start_state[i] for i in range(len(edited_joints))},
            use_container_width=True,
            num_rows="fixed",
            key="start_state_editor",
        )
        start_state = [start_state[f"J{i+1}"] for i in range(len(edited_joints))]
    with col_target:
        target_state = _float_list(report.get("ik_solution"), 0.0, len(edited_joints))
        target_state = st.data_editor(
            {f"J{i+1}": target_state[i] for i in range(len(edited_joints))},
            use_container_width=True,
            num_rows="fixed",
            key="target_state_editor",
        )
        target_state = [target_state[f"J{i+1}"] for i in range(len(edited_joints))]

    st.subheader("Code generation parameters")
    steps = st.slider("Interpolation steps per leg", 60, 2400, 960, step=60)
    frame_ms = st.number_input("Frame delay (ms)", 5, 40, 16, 1)

    c_code = generate_c_template(
        dof=len(edited_joints),
        joint_types=joint_types,
        link_lengths=link_lengths,
        start_state=start_state,
        target_state=target_state,
        steps=steps,
        frame_ms=frame_ms,
    )

    st.subheader("Generated C code")
    st.code(c_code, language="c")

    augmented_report = report.copy()
    augmented_report.update(
        {
            "joints": edited_joints,
            "home_state": start_state,
            "ik_solution": target_state,
            "gravity": report.get("gravity", 9.81),
            "codegen": {"steps": steps, "frame_ms": frame_ms},
            "c_code": c_code,
        }
    )

    st.download_button(
        "Download updated JSON (with C code)",
        data=json.dumps(augmented_report, indent=2),
        file_name="robot_codegen.json",
        use_container_width=True,
    )


if __name__ == "__main__":
    main()
